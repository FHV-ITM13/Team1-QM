\chapter{Einführung}
Das Hochhalten von Softwarequalität ist eine sehr anspruchsvolle Aufgabe, welche eine gewisse Planung vorraussetzt. Gerade bei Projekten mit hohen Budgets und materiellen Einsätzen werden hohe Anforderungen an das Qualitätsmanagement gesetzt.

Einige bekannte Fehlschläge in der Softwareentwicklung hätten wahrscheinlich mit besseren Qualitätssicherungsmaßnahmen verhindert werden können:

\begin{itemize}
    \item Pioneer 4 verfehlte den Mond
    \item unnötige Mahnungen durch die französische Finanzverwaltung
    \item das Herausgeben von faulen Krediten, was schlussendlich zum Bankencrash geführt hat
    \item Verlust einer Segelyacht im Pazifik
\end{itemize}

\section{Verifikation und Validierung}
Die Begriffe sollten klar getrennt werden, da sie nicht synonym verwendet werden können, und bei Softwareprozessen und Softwarequalität eine gewichtige Rolle spielen.

Die Verifikation stellt fest ob die Software mit der vorhandenen Spezifikation übereinstimmt, wohingegen die Validierung bestimmt ob die Software für den Kunden auch wirklich nützlich ist.

\section{Technical Debt}
Technical Debts sind ein wichtiges Thema in der Qualitätssicherung. Der Begriff wurde aus dem Finanzwesen übernommen (Debt = Schulden). In der Softwareentwicklungen ist damit gemeint, dass ungeschickte Lösungen irgendwann gefixt werden müssen.

Diese technische Schulden kann man bewusst eingehen, um Termine zu halten. Allerdings muss man immer im Hinterkopf behalten, dass man diese Schulden zu einem späteren Zeitpunkt auch wieder bezahlen muss.

Einer der größten Unterschiede zwischen klassischen und agilen Projektmanagementmethoden ist der Umgang mit diesen technischen Schulden. Bei agilen Methoden werden diese Schulden bewusst eingegangen, um ein schnelleres iteratives Vorgehen zu gewährleisten. Bei diesen Methodiken ist allerdings auch die Gefahr einer Überschuldung ungleich höher als bei den klassichen.

Allerdings werden in der Regel auch bei klassischen Methoden technische Schulden verursacht, nämlich in Form von Änderungen in den Anforderungen, auf welche in agilen Methoden besser reagiert werden kann.

\chapter{Hausaufgabe Besprechnung}
Es sollte klar definiert werden was in den Sonderfällen passiert bzw. was in diesen Fällen zurückgegeben wird (z.B. komplexe Zahlen da in Wurzel negative Zahl). Gleitkommzahlen sind "Teufelswerk"! Wenn man zwei gleiche Zahlen (die berechnet wurden aber unterschiedliche Rundungsfehler haben) voneinander voneinander subtrahiert bleibt nicht 0 übrig sondern der Rundungsfehler. Durch Rundungsfehler können somit 2 verschiedene Ergebnisse entstehen die eigentlich eines wären - darum könnte man anstatt der Mitternachtsformel eine andere Formel / einen anderen Ansatz verwenden (z.B. Newton-Näherungsverfahren). 

\begin{quote}"Als Softwareentwickler ist es durchaus erlaubt sein Hirn einzuschalten! - Gleitkommzahlen sind Teufelswerk!"\end{quote} 

\chapter{Wichtige Begriffe}

\begin{itemize}
    \item Softwareprozesse (Abfolge von Tätigkeiten, durch die ein Software-Produkt entsteht)
    \item Vorgehensmodell (Vereinfachte Beschreibung eines Softwareprozesses)
    \item Methode (Strukturierter Ansatz für die Software-Entwicklung)
\end{itemize}

\section{Software-Engineering}
Software-Engineering ist eine technische Disziplin  welche eine Lösung für den Anwender bieten will unter Einsatz von Theorien, Methoden und Werkzeugen und Berücksichtigung von Organisation, Management und Entwicklung. 

\section{Informatik}
Grundlage der Wissenschaft für Software-Ingeneure (Theorie, Konzepte, ...).

\section{ESSENCE Kernel Overview}
\img{0.9}{document/graphics/essence_kernel_overview.png}{ESSENCE Kernel Overview}{EKO}
In diesem Model gibt es verschiedene Zustände für die Anforderungen und jeder dieser Zustände hat selbst wieder Kriterien welche einem dabei helfen in welchem Zustein ein Projekt ist.
\paragraph{Zustände:}
\begin{itemize}
    \item Conceived
    \item Bounded
    \item Coherent
    \item Accepted
    \item Adressed
    \item Fulfilled
\end{itemize}

\section{Qualität}
Grad in dem die inhärenten Eigenschaften des Produkts Anforderungen erfüllen.

\begin{itemize}
	\item \textbf{Explizite Anforderungen}
	\item \textbf{Implizite Anforderungen} - Anforderungen welche existieren aber den Stakeholdern nicht bewusst sind.
	\item \textbf{Nicht explizite Anforderungen} - Stakeholer wissen, dass sie diese Anforderungen gibt aber sie teilen diese nicht mit (sind quasis eh klar).
	\item \textbf{Objektiv} - Vollkommen klar, dass man etwas braucht.
	\item \textbf{Subjektiv} - Vermeintliche Anforderungen, welche nicht wirklich wichtig sind.
	\item alle betroffenen / interessierten Personen
\end{itemize}

\subsection{Begriffsabgrenzung}
\paragraph{Technisches computer-basiertes System} System welches ausschließlich  aus Soft- und Hardware-Komponenten besteht.
\paragraph{Soziotechnisches System} System bestehend aus einem oder mehreren technischen Systemen, den Menschen die es bedienen, den notwendingen Arbeitsprozessen, organisatorischen Richtlinien, usw.

\emph{Systeme:}
\begin{itemize}
	\item haben systemspezifische Eigenschaften die nur dem System als Ganzem zugeordnet werden können
	\item sind häufig nicht deterministisch
	\item hängen von organisatorischen Zielen ab
\end{itemize}

\section{Kritische Systeme}
Relevante Systemeigenschaften für kritische Systeme sind:
\begin{itemize}
	\item Reparierfähigkeit
	\item Wartbarkeit
	\item Überlebensfähigkeit
	\item Fehlertoleranz
\end{itemize}

\paragraph{Kritisches System}
Systeme, bei dessen Ausfall oder Fehlfunktion großen Schaden anrichten kann (wirtschaftliche Verluste, physische Schäden, Gefahr für Gesundheit und Leben von Menschen).

\paragraph{Sicherheitskritisches System}
Schäden an der Umwelt und/oder Gefahr für Gesundheit und Leben von Menschen (Bohrinsel im Golf von Mexiko).

\paragraph{Aufgabenkritisches System}
Aufgaben die ein System erledigen solle werden nicht durchgeführt (z.B. Bank).

\paragraph{Geschäftskritisches System}
Extrem hohe Kosten bzw. signifikante Gewinnausfälle können die Folge eines Systemausfalls sein.


\todo{do fehlt a stuck}

\section{Sammlung von Anforderungen}

\subsection{Interviews}
\paragraph{Technik}
\begin{itemize}
\item Interviews mit Fragebogen
\item Geschlossene Interviews vorgegebener Fragebogen abarbeiten
\item Offene Interviews mit einer Diskussion zwischen Analyseteam und Beteiligten
\end{itemize}

\paragraph{Durchführungsempfehlung}
\begin{itemize}
\item Mischung aller Methoden 
\item Vorbereitung aller Diskussionen als geschlossenes Interview 
\item gut und interessiert zuhören
\item gezielt Fragen
\end{itemize}

\paragraph{Probleme}
\begin{itemize}
\item Jargon des Anwendungsgebiets 
\item Implizites Wissen
\end{itemize}

\paragraph{Eignung}
\begin{itemize}
\item Verständnis der Benutzeranforderungen 
\item Ergänzung zu anderen Informationsquellen mit zum Beispiel Dokumentationen oder Beobachtungen
\end{itemize}

\paragraph{Szenarien}
\begin{itemize}
\item {
Grundbestandteile
\begin{itemize}
\item Ausgangssituation
\item Ereignisablauf
\item Ausnahmen und ihre Behandlung
\end{itemize}
}
\item {
Varianten
\begin{itemize}
\item Ad-hoc
\item Formell
\end{itemize}
}
\end{itemize}

\subsection{Ethnografische Methode (Völkerkunde)}
Grundidee: Beobachten ohne einzugreifen

\begin{itemize}
\item Beobachten der alltäglichen Arbeit im normalen Umfeld
\item Notieren von Auffälligen
\item Diskussion mit Experten
\item Ableitung der Anforderungen
\end{itemize}

\paragraph{Stärken}
\begin{itemize}
\item Erkennen von impliziten Anforderungen 
\item Erkennen von nicht explizierten Anforderungen
\item Erkennen von Abweichungen
\end{itemize}

\img{0.9}{document/graphics/ethnogfrafisch.png}{Verknüpfung von Ethografie und Prototypen nach Sommerville (Copyright Pearson Studium 2007)}{ethnogfrafisch}

\newpage
\section{Klassifizierung von Anforderungen}

\img{0.8}{document/graphics/metamodel.png}{Metamodell}{metamodel}

\paragraph{Aufgaben}

\begin{itemize}
\item Erkennen von Duplikaten / Synonymen 
\item Beziehungen zwischen Anforderungen 
\item Gruppierung der Anforderungen 
\end{itemize}

\section{Validierung von Anforderungen}
Wichtige Prüfungen sind:

\begin{itemize}
\item Gültigkeitsprüfung
\item Konsistenzprüfung
\item Vollständigkeitsprüfung (schwierig, aber mit etwas Bauchgefühl machbar)
\item Realisierbarkeitsprüfung
\item Verifizierbarkeitsprüfung
\end{itemize}

\subsection{Techniken}
Prototypen erstellen und Testfälle entwickeln. Falls das nicht möglich sind die Anforderugnen schlecht definiert.

\subsection{Review}
\paragraph{Teamzusammensetzung}
Es sollten Vertreter aller am Projekt beteiligten bzw. vom Projekt betroffenen Gruppen auf Anwenderseite, ausserdem Systemarchitekten und Vertreter der Softwareentwickler.

\paragraph{Durchführung}
Die Führung der Analyse liegt bei den jeweiligen Anwendervertretern. Diskutiert werden sollten alle Anforderungen. Dadurch können Fehler, Konflikte und Wiedersprüche aufgedekt werden. Das Ergebnis ist ein Review Bericht.

\paragraph{Prüfungen}
Die Konsistenz der Anforderungen sollten am Ende geprüft werden. Ausserdem sollte eine Vollständigkeitsprüfung durchgeführt werden.

\subsection{Priorisierung von Anforderungen}

\paragraph{Grundgedanke}
Phasenweise Implementierung der Software. 

\subsubsection{Prioritätsfestlegung}
Teams festlegen, die nicht miteinander kommunizieren sollten. Ausserdem wird eine Bewertungsformel festgelegt.

\paragraph{Nutzwertanalyseteam}
Bewertet den Nutzen für die Anwender.

\paragraph{Kostenanalyseteam}
Schätzt die Kosten jeder Anforderung


\subsubsection{Auswertung}

\paragraph{Einflussgrößen}
\begin{itemize}
\item Nutzwert jeder Anforderung
\item Kosten jeder Anforderung
\item Obergrenze des Aufwands für Stufe 1
\item Abhängigkeiten
\end{itemize}

\paragraph{Ergebnis}
Liste der Anforderungen für nächste (bzw. erste) Ausbaustufe

\newpage
\section{Systemmodelle}

\paragraph{Kontextmodelle}
Definiert die Systemgrenzen des Gesamtsystems und des technischen Systems. Das Gesamtsystem umfasst das Technische System und die Menschliche Komponente und definiert den Kontext. Das Technische System definiert den Scope.

\img{1}{document/graphics/kontextmodelle.png}{Kontextmodelle}{kontextmodelle}

\newpage
\paragraph{Verhaltensmodelle}
Definiert die Abläufe in einem System. Sie können Datenfluss (Datenfocus) - oder Ereignis (Ereignisfocus) - Orientiert geschehen. Aussderm gibt es Mischformen davon. Dafür können Datenflussdiagramme (Abbildung \imgref{verhaltensmodelle}), Zustandstabelld (Abbildung \imgref{zustandstabelle}) und ähnliches verwendet werden.
 
\img{1}{document/graphics/verhaltensmodelle.png}{Datenflussdiagramm}{verhaltensmodelle}

\img{1}{document/graphics/zustandstabelle.png}{Zustandtabelle}{zustandstabelle}

\paragraph{Datenmodelle}
Definiert die logische und persistente (lokal, übergreifend mttels Datenbank und Datenaustausch) Datenstruktur. Dazu kann ER-, UML-Diagramme, OWL oder andere Ontologie-Darstellungen und andere.
 
\newpage
\paragraph{Objektorientierte Modellierung}
Vereinigt die Funktionalität von Daten- und Verhaltensmodelle und können Daten, Datenflüsse, Datenstrukturen und Erreignise erfassen. Als Notation wird meist UML verwendet.

\img{1}{document/graphics/objektorientiert.png}{Objektorientierte Modellierung}{objektorientiert}

Sind die Klassen in dem Diagramm Abbildung \imgref{objektorientiert} wirklich \textbf{Klassen oder Rollen}? Nein das sind eindeutig Rollen.

\newpage
\paragraph{Strukturierte Methoden}
Detailliert definierte Vorgehensweise bei der SW-Entwicklung. Normalerweise basierend auf einem Satz von Diagrammtypen. Definiert zusätzliche Regeln und Richtlinien. Beispiele dafür sind JSP, V-Modell oder RUP. Nachteile davon sind Mangelnde Unterstützung nicht-funktionaler Anforderungen und Anwendbarkeit für konkretes Problem oft schwer zu entscheiden.

\img{1}{document/graphics/strukturiert.png}{Strukturierte Methoden}{strukturiert}











